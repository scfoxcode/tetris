<canvas id="myCanvas" width="400" height="560" style="border:1px black solid"/>
<script>

var tetrisShapes =
{
    lBlock:
    {
        color:"green",
        shape:
        [
            [0 ,0, 0],
            [0, 1, 1],
            [1, 1, 0]
        ]
    },
    square:
    {
        color:"red",
        shape:
        [
            [1 ,1],
            [1, 1]
        ]
    }
};

var worldToCell = function(position, cellSize)
{
    return {x:position.x%cellSize.x, y:position.y%cellSize.y};
};

var cellToWorld = function(cell, cellSize)
{
    return {x:cell.x*cellSize, y:cell.y*cellSize};
};

var drawCell = function(ctx, color, worldPosition, cellSize)
{
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.fillRect(worldPosition.x+1, worldPosition.y+1, cellSize-2, cellSize-2);
    ctx.closePath();
};

TetrisShape = function()
{
    this.type = "";
    this.position = {x:0, y:0};
    this.init = function(type)
    {
        this.type = type;
        this.data = tetrisShapes[type];
    };
};

TetrisShape.prototype.spacesLeft = function() // Number of empty columns on left
{
    var minSpace = 5;
    var shape = this.data.shape;
    for(var i=0; i<shape.length; i++) // Rows
    {
        for(var j=0; j<shape[i].length; j++) // Columns
        {
            if(shape[j] == 1 && j < minSpace)
            {
                minSpace = j;
                break;
            }
        }
    }
    return minSpace;
};

TetrisShape.prototype.spacesRight = function() // Number of empty columns on left
{
    var minSpace = 5;
    var shape = this.data.shape;
    for(var i=0; i<shape.length; i++) // Rows
    {
        for(var j=0; j<shape[i].length; j++) // Columns
        {
            if(shape[j] == 1 && j < minSpace)
            {
                minSpace = j;
                break;
            }
        }
    }
    return minSpace;
};

TetrisShape.prototype.moveLegal = function(grid, direction)
{
    // Collision with left boundry
    if(this.position.x)
    {

    }
};

TetrisShape.prototype.move = function(grid, direction)
{

};

TetrisShape.prototype.draw = function(ctx, cellSize)
{
    var worldPosition = cellToWorld(this.position, cellSize);
    var shape = this.data.shape;
    var color = this.data.color;
    for(var i=0; i<shape.length; i++)
    {
        for(var j=0; j<shape[i].length; j++)
        {
            var position = {x:worldPosition.x + cellSize*j, y:worldPosition.y + cellSize*i};
            drawCell(ctx, color, position, cellSize);
        }
    }
};

Tetris = function(canvas) // Id of the canvas to draw to
{
    this.canvas = document.getElementById(canvas);
    this.ctx = this.canvas.getContext("2d");
    this.canvasSize = {x:parseInt(this.canvas.width), y:parseInt(this.canvas.height)};
    this.loopTimeout = null; // Holds game loop timeout reference
    this.activeShape = null; // Current active shape, if null create new
};

// Start Draw Functions
Tetris.prototype._drawGrid = function(grid, cellSize, gridSize)
{
    // Draw vertical lines
    var ctx = this.ctx;
    var canvasSize = this.canvasSize;
    for(var i=0; i<gridSize.x; i++)
    {
        ctx.beginPath();
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 1;
        ctx.moveTo(i*cellSize, 0);
        ctx.lineTo(i*cellSize, canvasSize.y);
        ctx.closePath();
        ctx.stroke();
    }

    // Draw horizontal lines
    for(i=0; i<gridSize.y; i++)
    {
        ctx.beginPath();
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 1;
        ctx.moveTo(0, i*cellSize);
        ctx.lineTo(canvasSize.x, i*cellSize);
        ctx.closePath();
        ctx.stroke();
    }
};

Tetris.prototype._redraw = function()
{
    var ctx = this.ctx;

    // Clear grid with background color
    ctx.beginPath();
    ctx.fillStyle = "#eee";
    ctx.fillRect(0, 0, this.canvasSize.x, this.canvasSize.y);
    ctx.closePath();

    this._drawGrid(this.grid, this.cellSize, this.gridSize);
    if(this.activeShape)
    {
        this.activeShape.draw(this.ctx, this.cellSize);
    }
};
// End Draw Functions

Tetris.prototype._createGrid = function(gridSize)
{
    var grid = [];
    for(var i=0; i<gridSize.x; i++)
    {
        grid[i] = [];
        for(var j=0; j<gridSize.y; j++)
        {
            grid[i][j] = null;
        }
    }
    return grid;
};

Tetris.prototype.userInput = function(self, data)
{
    if(self.activeShape)
    {
        if(data && data.key == 'a')
        {
            self.activeShape.position.x -= 1;
        }
        else if(data && data.key == 'd')
        {
            self.activeShape.position.x += 1;
        }
        self._redraw();
    }
};

Tetris.prototype.init = function(cellSize, gridSize)
{
    this.cellSize = cellSize;
    this.gridSize = gridSize;
    this.grid = this._createGrid(gridSize);
    var self = this;
    document.onkeypress = function(data)
    {
        Tetris.prototype.userInput(self, data);
    };
};

Tetris.prototype._innerGameLoop = function()
{
    if(this.activeShape)
    {
        this.activeShape.position.y += 1;
    }
    else // We need to create a new shape
    {
        this.activeShape = new TetrisShape();
        this.activeShape.init("square");
    }
    this._redraw();
};

Tetris.prototype._gameLoop = function()
{
    var self = this;
    self._innerGameLoop();
    this.loopTimeout = setTimeout(function()
    {
        self._gameLoop();
    }, 1000);
};

Tetris.prototype.run = function()
{
    this._gameLoop();
};

var game = new Tetris("myCanvas");
game.init(40, {x:10, y:14});
game.run();

</script>




